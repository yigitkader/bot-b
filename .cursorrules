# Cursor AI Rules for Trading Bot Project

## ğŸ¯ Project Context
This is a Rust-based trading bot for Binance Futures with event-driven architecture.

## ğŸ“‹ Code Standards

### 1. NO Mock/Dummy Data in Production Code
- âŒ NEVER use hardcoded test values (e.g., `50000`, `100.0`) in `src/` files
- âœ… ALWAYS use real API data or config values
- âœ… Test files (`tests/`) can use mock data, but prefer real API data
- âœ… Fallback values MUST come from config, not hardcoded

### 2. Config-Driven Parameters
- âœ… ALL parameters MUST come from `config.yaml` via `AppCfg`
- âœ… Provide default values for all config fields
- âœ… NEVER hardcode business logic values
- âœ… Use `#[serde(default = "default_function")]` for defaults

### 3. Error Handling
- âŒ NEVER use `unwrap()` in production code (only in tests)
- âœ… ALWAYS use `Result<T>` pattern
- âœ… Use `anyhow::Error` with context
- âœ… Handle Mutex/RwLock poisoning gracefully
- âœ… Use `unwrap_or_else()` for safe fallbacks

### 4. Lifetime & Ownership
- âŒ NEVER use `&self` inside `tokio::spawn` closures
- âœ… ALWAYS clone required values before `tokio::spawn`
- âœ… Use `Arc<T>` for shared ownership
- âœ… Clone config before moving into async tasks

### 5. Thread Safety
- âœ… Use `Arc<T>` for shared state
- âœ… Use `RwLock` for read-heavy, `Mutex` for write-heavy
- âœ… Handle poisoning with `match` or `unwrap_or_else`
- âœ… Use atomic operations when appropriate

### 6. Event Bus Pattern
- âœ… Subscribe to events via `event_bus.subscribe_*()`
- âœ… Publish events via `event_bus.*_tx.send()`
- âœ… Use broadcast channels for multi-subscriber events
- âœ… Include timestamps in all events

### 7. Rate Limiting
- âœ… ALWAYS use `crate::utils::rate_limit_guard(weight).await` before API calls
- âœ… Use correct weight values (see Binance API docs)
- âœ… Never bypass rate limiting

### 8. Type Safety
- âœ… Use type aliases: `Px`, `Qty`, `Side`
- âœ… Prefer `Decimal` over `f64` for financial calculations
- âœ… Use `Option<T>` for optional values
- âœ… Use `Result<T>` for fallible operations

### 9. Documentation
- âœ… Add doc comments for all public functions
- âœ… Document complex logic with inline comments
- âœ… Update `ARCHITECTURE.md` when adding modules
- âœ… Update `MODULE_DOCUMENTATION.md` when changing modules

### 10. Testing
- âœ… Write unit tests for each module
- âœ… Use real API data in integration tests (no mocks)
- âœ… Test error cases, not just happy paths
- âœ… Run `cargo test` before committing

## ğŸ” Code Review Checklist

Before making changes, check:
1. âœ… No mock/dummy data in production code
2. âœ… All parameters from config
3. âœ… Proper error handling (no unwrap)
4. âœ… Lifetime safety (no &self in tokio::spawn)
5. âœ… Thread safety (Arc, Mutex, RwLock)
6. âœ… Rate limiting on API calls
7. âœ… Type safety (Decimal, Option, Result)
8. âœ… Documentation updated
9. âœ… Tests pass

## ğŸš¨ Red Flags (Fix Immediately)

- `unwrap()` in production code
- Hardcoded values instead of config
- Mock data in `src/` files
- `&self` in `tokio::spawn`
- Race conditions
- Memory leaks
- Panic risks

## ğŸ“š Architecture

- **Event-Driven**: Modules communicate via EventBus
- **Modular**: Each module has single responsibility
- **Config-Driven**: All parameters from config.yaml
- **Thread-Safe**: Arc + Mutex/RwLock pattern
- **No Mock Data**: Real API data in production

## ğŸ”„ Module Dependencies

See `ARCHITECTURE.md` for complete dependency graph.

## ğŸ“ Naming Conventions

- Structs: `PascalCase` (e.g., `MarketTick`)
- Functions: `snake_case` (e.g., `calculate_pnl`)
- Constants: `UPPER_SNAKE_CASE` (e.g., `MAX_POSITION_DURATION_SEC`)
- Modules: `snake_case` (e.g., `follow_orders`)

## ğŸ§ª Testing Strategy

1. Unit tests in each module (`#[cfg(test)]`)
2. Integration tests in `tests/backtest.rs` (real API data)
3. Compile tests in `tests/compile_test.rs`

## ğŸš€ Adding New Modules

1. Create file in `src/`
2. Add to `src/lib.rs`
3. Add to `src/main.rs` imports
4. Subscribe to EventBus events
5. Update config if needed
6. Add tests
7. Update documentation

