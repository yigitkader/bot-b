// Event bus system for module communication
// All modules communicate through events, no direct coupling

// Re-export all event types from types.rs for convenience
pub use crate::types::{
    BalanceUpdate, CloseReason, CloseRequest, FillHistoryAction, FillHistoryData,
    LogEvent, MarketTick, OpenOrderSnapshot, OpenPositionSnapshot,
    OrderFillHistoryUpdate, OrderingStateUpdate, OrderStatus, OrderUpdate,
    PositionUpdate, TradeSignal,
};

// ============================================================================
// Event Bus
// ============================================================================

use tokio::sync::{broadcast, mpsc};

/// Event bus for module communication
/// Each module subscribes to events it needs
/// Uses broadcast channels for multiple subscribers
pub struct EventBus {
    pub market_tick_tx: broadcast::Sender<MarketTick>,
    
    pub trade_signal_tx: broadcast::Sender<TradeSignal>,
    
    pub close_request_tx: broadcast::Sender<CloseRequest>,
    
    pub order_update_tx: broadcast::Sender<OrderUpdate>,
    
    pub position_update_tx: broadcast::Sender<PositionUpdate>,
    
    pub balance_update_tx: broadcast::Sender<BalanceUpdate>,
    
    pub ordering_state_update_tx: broadcast::Sender<OrderingStateUpdate>,
    
    pub order_fill_history_update_tx: broadcast::Sender<OrderFillHistoryUpdate>,
    
    pub log_event_tx: mpsc::UnboundedSender<LogEvent>,
}

impl EventBus {
    /// Create a new EventBus with custom buffer sizes.
    ///
    /// This constructor allows you to configure buffer sizes for each event channel based on
    /// expected event frequency and subscriber processing speed.
    ///
    /// # Arguments
    ///
    /// * `cfg` - EventBusCfg containing buffer sizes for each event channel
    ///
    /// # Returns
    ///
    /// Returns a new `EventBus` instance with configured buffer sizes.
    ///
    /// # Example
    ///
    /// ```no_run
    /// use crate::config::EventBusCfg;
    ///
    /// let cfg = EventBusCfg {
    ///     market_tick_buffer: 10000,
    ///     trade_signal_buffer: 1000,
    ///     ..Default::default()
    /// };
    /// let event_bus = EventBus::new_with_config(&cfg);
    /// ```
    pub fn new_with_config(cfg: &crate::config::EventBusCfg) -> Self {
        let (market_tick_tx, _) = broadcast::channel(cfg.market_tick_buffer);
        let (trade_signal_tx, _) = broadcast::channel(cfg.trade_signal_buffer);
        let (close_request_tx, _) = broadcast::channel(cfg.close_request_buffer);
        let (order_update_tx, _) = broadcast::channel(cfg.order_update_buffer);
        let (position_update_tx, _) = broadcast::channel(cfg.position_update_buffer);
        let (balance_update_tx, _) = broadcast::channel(cfg.balance_update_buffer);
        let (ordering_state_update_tx, _) = broadcast::channel(1000); // Buffer for state updates
        let (order_fill_history_update_tx, _) = broadcast::channel(1000); // Buffer for fill history updates
        let (log_event_tx, _) = mpsc::unbounded_channel();
        
        Self {
            market_tick_tx,
            trade_signal_tx,
            close_request_tx,
            order_update_tx,
            position_update_tx,
            balance_update_tx,
            ordering_state_update_tx,
            order_fill_history_update_tx,
            log_event_tx,
        }
    }
    
    /// Create a new EventBus with default buffer sizes.
    ///
    /// This constructor uses default buffer sizes (10000 for MarketTick, 1000 for others).
    /// For custom buffer sizes, use `new_with_config()` instead.
    ///
    /// # Returns
    ///
    /// Returns a new `EventBus` instance with default configuration.
    ///
    /// # Example
    ///
    /// ```no_run
    /// let event_bus = EventBus::new();
    /// ```
    pub fn new() -> Self {
        let default_cfg = crate::config::EventBusCfg::default();
        Self::new_with_config(&default_cfg)
    }
    
    /// Subscribe to market tick events.
    ///
    /// Returns a new broadcast receiver that will receive all MarketTick events published
    /// to the event bus. Each call creates a new independent receiver.
    ///
    /// # Returns
    ///
    /// Returns a `broadcast::Receiver<MarketTick>` that can be used to receive market tick events.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # let event_bus = crate::event_bus::EventBus::new();
    /// let mut receiver = event_bus.subscribe_market_tick();
    /// // Use receiver.recv().await to receive events
    /// ```
    pub fn subscribe_market_tick(&self) -> broadcast::Receiver<MarketTick> {
        self.market_tick_tx.subscribe()
    }
    
    /// Subscribe to trade signal events.
    ///
    /// Returns a new broadcast receiver for TradeSignal events generated by the TRENDING module.
    ///
    /// # Returns
    ///
    /// Returns a `broadcast::Receiver<TradeSignal>` for receiving trade signals.
    pub fn subscribe_trade_signal(&self) -> broadcast::Receiver<TradeSignal> {
        self.trade_signal_tx.subscribe()
    }
    
    /// Subscribe to close request events.
    ///
    /// Returns a new broadcast receiver for CloseRequest events published by FOLLOW_ORDERS module.
    ///
    /// # Returns
    ///
    /// Returns a `broadcast::Receiver<CloseRequest>` for receiving close requests.
    pub fn subscribe_close_request(&self) -> broadcast::Receiver<CloseRequest> {
        self.close_request_tx.subscribe()
    }
    
    /// Subscribe to order update events.
    ///
    /// Returns a new broadcast receiver for OrderUpdate events published by CONNECTION module
    /// when orders are filled, canceled, or updated.
    ///
    /// # Returns
    ///
    /// Returns a `broadcast::Receiver<OrderUpdate>` for receiving order updates.
    pub fn subscribe_order_update(&self) -> broadcast::Receiver<OrderUpdate> {
        self.order_update_tx.subscribe()
    }
    
    /// Subscribe to position update events.
    ///
    /// Returns a new broadcast receiver for PositionUpdate events published by CONNECTION module
    /// when positions are opened, closed, or updated.
    ///
    /// # Returns
    ///
    /// Returns a `broadcast::Receiver<PositionUpdate>` for receiving position updates.
    pub fn subscribe_position_update(&self) -> broadcast::Receiver<PositionUpdate> {
        self.position_update_tx.subscribe()
    }
    
    /// Subscribe to balance update events.
    ///
    /// Returns a new broadcast receiver for BalanceUpdate events published by BALANCE module
    /// when USDT or USDC balances change.
    ///
    /// # Returns
    ///
    /// Returns a `broadcast::Receiver<BalanceUpdate>` for receiving balance updates.
    pub fn subscribe_balance_update(&self) -> broadcast::Receiver<BalanceUpdate> {
        self.balance_update_tx.subscribe()
    }
    
    /// Subscribe to ordering state update events.
    ///
    /// Returns a new broadcast receiver for OrderingStateUpdate events published by ORDERING module
    /// when OrderingState changes (order placed, filled, canceled, position opened/closed).
    /// STORAGE module listens to this event to persist state.
    ///
    /// # Returns
    ///
    /// Returns a `broadcast::Receiver<OrderingStateUpdate>` for receiving state updates.
    pub fn subscribe_ordering_state_update(&self) -> broadcast::Receiver<OrderingStateUpdate> {
        self.ordering_state_update_tx.subscribe()
    }
    
    /// Subscribe to order fill history update events.
    ///
    /// Returns a new broadcast receiver for OrderFillHistoryUpdate events published by CONNECTION module
    /// when order fill history changes (new fill, order closed).
    /// STORAGE module listens to this event to persist fill history.
    ///
    /// # Returns
    ///
    /// Returns a `broadcast::Receiver<OrderFillHistoryUpdate>` for receiving fill history updates.
    pub fn subscribe_order_fill_history_update(&self) -> broadcast::Receiver<OrderFillHistoryUpdate> {
        self.order_fill_history_update_tx.subscribe()
    }
    
    /// Get health statistics for monitoring event bus status.
    ///
    /// Returns receiver counts for all event channels, which can be used to detect if modules
    /// have crashed or if there are no subscribers for critical events.
    ///
    /// # Returns
    ///
    /// Returns an `EventBusHealth` struct containing receiver counts for each event channel.
    /// A count of 0 indicates no active subscribers, which may indicate a module has panicked.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # let event_bus = crate::event_bus::EventBus::new();
    /// let health = event_bus.health_stats();
    /// if health.order_update_receivers == 0 {
    ///     eprintln!("Warning: No OrderUpdate subscribers!");
    /// }
    /// ```
    pub fn health_stats(&self) -> EventBusHealth {
        EventBusHealth {
            market_tick_receivers: self.market_tick_tx.receiver_count(),
            trade_signal_receivers: self.trade_signal_tx.receiver_count(),
            close_request_receivers: self.close_request_tx.receiver_count(),
            order_update_receivers: self.order_update_tx.receiver_count(),
            position_update_receivers: self.position_update_tx.receiver_count(),
            balance_update_receivers: self.balance_update_tx.receiver_count(),
            ordering_state_update_receivers: self.ordering_state_update_tx.receiver_count(),
            order_fill_history_update_receivers: self.order_fill_history_update_tx.receiver_count(),
        }
    }
}

/// Health statistics for event bus monitoring
#[derive(Debug, Clone)]
pub struct EventBusHealth {
    pub market_tick_receivers: usize,
    pub trade_signal_receivers: usize,
    pub close_request_receivers: usize,
    pub order_update_receivers: usize,
    pub position_update_receivers: usize,
    pub balance_update_receivers: usize,
    pub ordering_state_update_receivers: usize,
    pub order_fill_history_update_receivers: usize,
}

impl Default for EventBus {
    fn default() -> Self {
        Self::new()
    }
}

